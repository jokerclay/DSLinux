# 排序基本概念

### 定义
* 使得表中的元素从**无序** 变 **有序**
* 表中的元素可以重复


### 评价指标
* 时间复杂度
* 空间复杂度
* 稳定性
    * 稳定：排序后相同元素的相对位置不变
    * 不稳定：排序后相同元素的相对位置改变

### 排序算法的分类
* 内部排序
    * 排序的所有元素都在内存中,在内存中对元素进行操作
    * 更关注空间复杂度和时间复杂度

* 外部排序
    * 排序的所有元素太大,没法一次读入内存,需要采取一部分一部分处理的策略
    * 关注空间复杂度和时间复杂度
    * 还要关注如何使读写磁盘的次数更少


# 直接插入排序

### 算法思想
* 默认第一个有序
* 后面的每一个依次：
    * 和前面的每一个(从后方向前)对比，
    * 比当前大的都后移
    * 把新来的放到对应的地方

### 算法效率
* 空间复杂度 O(1)
* 时间复杂度 最好O(n) 最坏O(n^2)
* 稳定的排序


# 折半插入排序

* 优化点在于 “新来的应该放到哪里的问题”
    从 “依次查找” 放进去，
    改为 “折半查找” 放进去，

* 时间复杂度 最好O(n) 最坏O(n^2)


# 希尔排序

### 算法思想

* 先追求部分基本有序
    * 每个子表的组成由增量决定,增量即每个元素相隔的量
    * 对每个子表进行插入排序
* 再逐渐逼近全局有序


# 冒泡排序

* 冒泡排序属于交换排序
* 快递排序属于交换排序
    * `交换排序` 根据两个元素的比较结果，记录在序列中的位置

* 从后往前,两两比较,大的往后站，第一趟结束，最小的冒泡到最前面
* 从后往前,两两比较,大的往后站，第二趟结束，第二小的冒泡到最前面
* ...


### 算法效率
* 空间复杂度 O(1)
* 时间复杂度 最好O(n) 最坏O(n^2)
* 稳定的排序


# 快速排序

* 冒泡排序: 每一次最大或最小确定最终位置
* 快速排序: 每一次中间元素确定最终位置

### 算法思想

* 选一个元素作为基准,即基准元素
* 基准元素 最终位置 要不剩下的元素中左半部分都大，比要不剩下的元素中右半部分都小,这样一次称为划分
    通过基准元素把剩下的元素划分为 左 右两个部分
* 使用 low 和 high 指向序列的头和尾
* 使用 low 指向的元素做为基准元素
* 让   low 和 high 向中间移动,把整个序列扫描一遍，保证 high 的右边都大于基准元素,保证 low 的左边都小于基准元素
* low 和 high 相遇的时候，则确定基准元素的位置
* 对左右两个子表做同样的划分

### 算法效率

* 时间复杂度 = O(n * 递归层数)

* 空间复杂度 = O(递归层数)

* n 个元素其实组织的是二叉树, 二叉树的层数就是递归调用的层数
* n 个节点的二叉树 
    最小高度  = floor(log_{2}{n}+1)
    最大高度  = n

故：
最好时间复杂度 = O(nlog_{2}{n})
最坏时间复杂度 = O(n^{2})


最好空间复杂度 = O(log_{2}{n})
最坏空间复杂度 = O(n)

快排平均性能最优

* 稳定性
`不稳定`


