# 排序基本概念

### 定义
* 使得表中的元素从**无序** 变 **有序**
* 表中的元素可以重复


### 评价指标
* 时间复杂度
* 空间复杂度
* 稳定性
    * 稳定：排序后相同元素的相对位置不变
    * 不稳定：排序后相同元素的相对位置改变

### 排序算法的分类
* 内部排序
    * 排序的所有元素都在内存中,在内存中对元素进行操作
    * 更关注空间复杂度和时间复杂度

* 外部排序
    * 排序的所有元素太大,没法一次读入内存,需要采取一部分一部分处理的策略
    * 关注空间复杂度和时间复杂度
    * 还要关注如何使读写磁盘的次数更少


# 直接插入排序

### 算法思想
* 默认第一个有序
* 后面的每一个依次：
    * 和前面的每一个(从后方向前)对比，
    * 比当前大的都后移
    * 把新来的放到对应的地方

### 算法效率
* 空间复杂度 O(1)
* 时间复杂度 最好O(n) 最坏O(n^2)
* 稳定的排序


# 折半插入排序

* 优化点在于 “新来的应该放到哪里的问题”
    从 “依次查找” 放进去，
    改为 “折半查找” 放进去，

* 时间复杂度 最好O(n) 最坏O(n^2)


# 希尔排序

### 算法思想

* 先追求部分基本有序
    * 每个子表的组成由增量决定,增量即每个元素相隔的量
    * 对每个子表进行插入排序
* 再逐渐逼近全局有序


# 冒泡排序

* 冒泡排序属于交换排序
* 快递排序属于交换排序
    * `交换排序` 根据两个元素的比较结果，记录在序列中的位置

* 从后往前,两两比较,大的往后站，第一趟结束，最小的冒泡到最前面
* 从后往前,两两比较,大的往后站，第二趟结束，第二小的冒泡到最前面
* ...


### 算法效率
* 空间复杂度 O(1)
* 时间复杂度 最好O(n) 最坏O(n^2)
* 稳定的排序


# 快速排序

* 冒泡排序: 每一次最大或最小确定最终位置
* 快速排序: 每一次中间元素确定最终位置

### 算法思想

* 选一个元素作为基准,即基准元素
* 基准元素 最终位置 要不剩下的元素中左半部分都大，比要不剩下的元素中右半部分都小,这样一次称为划分
    通过基准元素把剩下的元素划分为 左 右两个部分
* 使用 low 和 high 指向序列的头和尾
* 使用 low 指向的元素做为基准元素
* 让   low 和 high 向中间移动,把整个序列扫描一遍，保证 high 的右边都大于基准元素,保证 low 的左边都小于基准元素
* low 和 high 相遇的时候，则确定基准元素的位置
* 对左右两个子表做同样的划分

### 算法效率

* 时间复杂度 = O(n * 递归层数)

* 空间复杂度 = O(递归层数)

* n 个元素其实组织的是二叉树, 二叉树的层数就是递归调用的层数
* n 个节点的二叉树 
    最小高度  = floor(log_{2}{n}+1)
    最大高度  = n

故：
最好时间复杂度 = O(nlog_{2}{n})
最坏时间复杂度 = O(n^{2})


最好空间复杂度 = O(log_{2}{n})
最坏空间复杂度 = O(n)

快排平均性能最优

* 稳定性
`不稳定`



# 简单选择排序

* 属于 选择排序

选择排序: 每一趟在待排序元素中选取关键字最小（最大）的元素加入有序子序列

### 算法思想

* 第一趟，从左向右，选取关键字最小的元素加入有序序列(放到最前面)
* 头部的一个就不用管了，第二趟从左向右，选取关键字最小的元素加入有序序列(放到第二个位置)


### 算法效率
* 空间复杂度 O(1)
* 时间复杂度 O(n^2)

* 稳定性
`不稳定`


# 堆排序

* 基于`堆` 这种数据结构

* `堆` 这种数据结构 物理上看是连续存放的数组，从逻辑上看应为一颗 完全二叉树

编号为 `1` 的节点是这颗二叉树的 根节点, 编号为 `i` 节点的 左孩子是 `2i` , 右孩子 `2i+1`


* `大根堆`
    * 任意 L(i) >= L(2i) && L(i) >= L(2i+1), (1 <= i <= n/2)
    * `大根堆` 完全二叉树中 `根>= 左，右`
    * 任一节点，一定比它的`左子树`和`右子树`更 `大`

* `小根堆`
    * 任意 L(i) <= L(2i) && L(i) <= L(2i+1), (1 <= i <= n/2)


* 基于`堆` 这种数据结构进行排序

`堆排序` 是选择排序的一种，基本思想是选中关键字（最大/最小） 的元素加入有序子序列

从大根堆中选中最大的 值就变得方便, 堆顶的值是最大的,从数组的视角来看，第一个元素是最大的

如果把序列变成一个  `大根堆`, 那么再选择排序就会变得很简单

* 如何建立大根堆 ? 即 所有的根节点 都大于它的左子树和右子树

    * 把所有的非终端节点都检查一遍，如果不符合`所有的根节点 都大于它的左子树和右子树`, 就调整
    即 `将当前结点与更大的一个孩子互换`

    * 在顺序存储的完全二叉树中，`非终端节点编号 i <= [n/2]`




┌──────────────────────────────┐
│📅 2025-08-13 🕒 16:32:06 周三│
└──────────────────────────────┘
let's force on merge sort now


#  归并排序

* 把两个或多个已经有序的序列, 合并成一个 (2路归并)

 i               j
 |               |
 V               V
 1 2 3 4         5 6 7 8

    min ? 1 : 5

 k
 |
 V
 1


   i             j
   |             |
   V             V
 1 2 3 4         5 6 7 8

    min ? 2 : 5

   k
   |
   V
 1 2

"2路归并" : 每选出一个小元素 只需对比关键字 1次

"4路归并"

p1 p2 p3 p4
|  |  |  |
V  V  V  V
 p12  p34
   |  |
   V  V
  p1234

"4路归并" : 每选出一个小元素 需对比关键字 3次

结论：`m 路 归并，每选出一个元素需要对比关键字 m-1 次`

归并排序的思路 (2路归并)

将无序的序列看做只有一个 元素的，单独的有序序列

1. 将相邻的两两二路归并

初始序列

49 38 65 97 76 12 27

第一趟

49 38 |  65 97  |   76 12  |   27
|  |  |  |  |   |   |  |   |   | 
V  V  |  V  V   |   V  V   |   V 
38 49 | 65  97  |  12 76   |   27

第二趟

49 38   65 97  |   76 12   27
  |       |    |    |      |
  V       V    |    V      V
38 49  65  97  |  12 76    27

38 49  65  97  |  12 27 76
     |         |      |
     V         |      V

12 27 38 49 65 76 97

核心操作: 要把有序数组归并为 1 个

1. A 中的 low -> high 复制到 B 数组中

```txt

        low      mid        high
         |        |          |
         V        V          V
A[..... 16 24 37 45   21 24 33 .....]

                             k
                             |
                             V
B[      16 24 37 45   21 24 33      ]

```

2. i 指向第一个数组的第一个元素, j 指向第二个数组的第一个元素

k 指明了小元素要放到哪里

如果 B[i] < B[j], 把小的值放到 k 所指的位置

### 算法思想

1. 分为两部分
2. 左半部分归并为有序序列
3. 右半部分归并为有序序列
4. 将左右两部分整体归并为有序序列

### 算法效率

时间复杂度：O(n log_2 ^{n})
空间复杂度：O(n) 来自辅助数组 B

稳定的数组

# 基数排序

按关键字得到递减的数列

关键字的 个 十 百 .... 取值可能为 0~9 的队列

``` txt
Q9 Q8 Q7 Q6 Q5 Q4 Q3 Q2 Q1 Q0
|  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |
|  |  |  |  |  |  |  |  |  |

```

520 211 438 888 007 111 985 666 996 233 168

第一趟，个位数进行分配
依次挂到对应的基数队列上

Q9 -> Q0, 依次收集起来

第二趟，十位数进行分配
依次挂到对应的基数队列上

Q9 -> Q0, 依次收集起来

第三趟，百位数进行分配
依次挂到对应的基数队列上

Q9 -> Q0, 依次收集起来

**基数排序并不是一个基于比较的排序算法**


### 算法效率

需要 r 个辅助队列， 空间复杂度：O(r)

一趟分配O(n), 一趟收集 O(r), 共 d 趟分配 时间复杂度：O(d(n+r))

基数排序是稳定的

### 基数排序的应用

关键字可以方便的拆分为d 组, d 不能特别多, d 小J

每组关键字的取值范围小, r 小

数据元素 n 个数较大

#  外部排序

磁盘中的数据和内存中的数据以块进行交换的


### 算法思想

1. 构造初始归并段

外部排序 使用 归并排序的方法，最少只需要在内存中分配 3 块大小的缓冲区，即可堆任意一个大文件排序

input buffer 1
input buffer 2

output buffer

1) 先从磁盘中读入两个内存磁盘块1,磁盘块2  到 input buffer 1 和 input buffer 2,
对input buffer 1 和 input buffer 2,分别进行内部排序, 
input buffer 1 和 input buffer 2 都变有序

2) 把input buffer 1 的序列放入 output buffer, output buffer 写回磁盘块 1
   把input buffer 2 的序列放入 output buffer, output buffer 写回磁盘块 2,
   磁盘中 磁盘块 1, 磁盘块 2, 变得递增有序, 得到第一个 归并段

3) 先从磁盘中读入两个内存磁盘块3,磁盘块4  到 input buffer 1 和 input buffer 2,
对input buffer 1 和 input buffer 2,分别进行内部排序, 
input buffer 1 和 input buffer 2 都变有序


4) 把input buffer 1 的序列放入 output buffer, output buffer 写回磁盘块 3
   把input buffer 2 的序列放入 output buffer, output buffer 写回磁盘块 4,
   磁盘中 磁盘块 3, 磁盘块 4, 变得递增有序, 得到第二个 归并段

....

构造出 **归并段**

2. 第一趟归并

将两个有序的归并段，归并为 一个较长的

3. 第二趟归并

将两个较长的有序的归并段，归并为 一个更长的有序的归并段

败者树:
        败者树是:两两对战，胜者上浮，树的最顶端是胜者

使用败者树 优化多路平衡归并

因为 败者树一旦建立，后续比较次数会减少

